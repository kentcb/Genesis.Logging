<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
// -----------------------------------------------------------------------
// <autogenerated>
//    This code was generated from a template.
//
//    Changes to this file may cause incorrect behaviour and will be lost
//    if the code is regenerated.
// </autogenerated>
// ------------------------------------------------------------------------

namespace Genesis.Logging
{
    using System;
    using System.Diagnostics;
    using System.Globalization;

    /// <summary>
    /// Provides extension methods for logging.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class provides extension methods against <see cref="ILogger"/> to simplify logging. All relevant methods are marked as
	/// conditional on the <c>LOGGING</c> symbol. That is, compiling without this symbol will elide logging calls.
    /// </para>
    /// <para>
    /// Extensions are provided for each level of logging (debug, information, warning, performance, and error). Each level has quite a few
    /// overloads, many of which are provided as a kind of poor man's variadic templates. Up to 10 parameters can be supplied without
    /// incurring an allocation. Thereafter, the <c>params</c> overloads will take over and an allocation cost will apply. Of course, if
    /// you don't have the <c>LOGGING</c> symbol defined then there is no cost whatsoever.
    /// </para>
    /// </remarks>
    public static class LoggerExtensions
    {
<#
		var methodNames = new[]
		{
			"Verbose",
			"Debug",
			"Info",
			"Warn",
			"Error",
			"Perf"
		};

		var variadicCount = 10;

		foreach (var methodName in methodNames)
		{
			var isPerf = methodName == "Perf";
			var attributes = isPerf ? "" : "[Conditional(\"LOGGING\")]";
			var returnType = isPerf ? "PerformanceBlock" : "void";
			var returnStatement = isPerf ? "return PerformanceBlock.Empty;" : "return;";#>
		/// <summary>
		/// Outputs a message with level <#= methodName.ToLowerInvariant() #> to the log.
		/// </summary>
		/// <param name="this">
		/// The <see cref="ILogger"/> against which to log.
		/// </param>
		/// <param name="message">
		/// The message.
		/// </param>
		<#= attributes #>
		public static <#= returnType #> <#= methodName #>(this ILogger @this, string message)
		{
			if (!@this.Is<#= methodName #>Enabled)
			{
				<#= returnStatement #>
			}

<# if (isPerf) { #>
			return new PerformanceBlock(@this, message);
<# } else { #>
			@this.Log(LogLevel.<#= methodName #>, message);
<# } #>
		}

		/// <summary>
		/// Outputs a message with level <#= methodName.ToLowerInvariant() #> to the log.
		/// </summary>
		/// <param name="this">
		/// The <see cref="ILogger"/> against which to log.
		/// </param>
		/// <param name="format">
		/// The format for the message.
		/// </param>
		/// <param name="args">
		/// Arguments to be substituted into <paramref name="format"/>.
		/// </param>
		<#= attributes #>
		public static <#= returnType #> <#= methodName #>(this ILogger @this, string format, params object[] args)
		{
			if (!@this.Is<#= methodName #>Enabled)
			{
				<#= returnStatement #>
			}

			var message = string.Format(CultureInfo.InvariantCulture, format, args);
<# if (isPerf) { #>
			return new PerformanceBlock(@this, message);
<# } else { #>
			@this.Log(LogLevel.<#= methodName #>, message);
<# } #>
		}

<# if (!isPerf) { #>
		/// <summary>
		/// Outputs a message with level <#= methodName.ToLowerInvariant() #> to the log, along with the details of an exception.
		/// </summary>
		/// <param name="this">
		/// The <see cref="ILogger"/> against which to log.
		/// </param>
		/// <param name="exception">
		/// The exception to include in the output.
		/// </param>
		/// <param name="format">
		/// The format for the message.
		/// </param>
		/// <param name="args">
		/// Arguments to be substituted into <paramref name="format"/>.
		/// </param>
		[Conditional("LOGGING")]
		public static void <#= methodName #>(this ILogger @this, Exception exception, string format, params object[] args)
		{
			if (!@this.Is<#= methodName #>Enabled)
			{
				return;
			}

			var message = string.Format(CultureInfo.InvariantCulture, format, args) + exception;
			@this.Log(LogLevel.<#= methodName #>, message);
		}

<# }

// now output variadic implementations of the method
for (var i = 1; i <= variadicCount; ++i)
{
	var typeParamNames = Enumerable
		.Range(0, i)
		.Select(n => "T" + n)
		.ToList();
	var commaSeparatedTypeParamNames = typeParamNames
		.Aggregate((acc, next) => acc + ", " + next);
	var typeParamDocs = typeParamNames
		.Select(t => "/// <typeparam name=\"" + t + "\">The type of parameter " + t + ".</typeparam>")
		.Aggregate((acc, next) => acc + Environment.NewLine + next);
	var paramDocs = Enumerable
		.Range(0, i)
		.Select(t => "/// <param name=\"arg" + t + "\">Argument " + t + ".</param>")
		.Aggregate((acc, next) => acc + Environment.NewLine + next);
	var variadicArguments = Enumerable
		.Range(0, i)
		.Select(t => "T" + t + " arg" + t)
		.Aggregate((acc, next) => acc + ", " + next);
	var variadicArgumentNames = Enumerable
		.Range(0, i)
		.Select(t => "arg" + t)
		.Aggregate((acc, next) => acc + ", " + next); #>
		/// <summary>
		/// Outputs a message with level <#= methodName.ToLowerInvariant() #> to the log.
		/// </summary>
		<#= typeParamDocs #>
		/// <param name="this">
		/// The <see cref="ILogger"/> against which to log.
		/// </param>
		/// <param name="format">
		/// The format of the message.
		/// </param>
		<#= paramDocs #>
		<#= attributes #>
		public static <#= returnType #> <#= methodName #><<#= commaSeparatedTypeParamNames #>>(this ILogger @this, string format, <#= variadicArguments #>)
		{
			if (!@this.Is<#= methodName #>Enabled)
			{
				<#= returnStatement #>
			}

			var message = string.Format(CultureInfo.InvariantCulture, format, <#= variadicArgumentNames #>);
<# if (isPerf) { #>
			return new PerformanceBlock(@this, message);
<# } else { #>
			@this.Log(LogLevel.<#= methodName #>, message);
<# } #>
		}

<# if (!isPerf) { #>
		/// <summary>
		/// Outputs a message with level <#= methodName.ToLowerInvariant() #> to the log, along with the details of an exception.
		/// </summary>
		<#= typeParamDocs #>
		/// <param name="this">
		/// The <see cref="ILogger"/> against which to log.
		/// </param>
		/// <param name="exception">
		/// The exception to include in the output.
		/// </param>
		/// <param name="format">
		/// The format of the message.
		/// </param>
		<#= paramDocs #>
		[Conditional("LOGGING")]
		public static void <#= methodName #><<#= commaSeparatedTypeParamNames #>>(this ILogger @this, Exception exception, string format, <#= variadicArguments #>)
		{
			if (!@this.Is<#= methodName #>Enabled)
			{
				return;
			}

			var message = string.Format(CultureInfo.InvariantCulture, format, <#= variadicArgumentNames #>) + exception;
			@this.Log(LogLevel.<#= methodName #>, message);
		}

<# }
			}
		}
		#>
	}
}